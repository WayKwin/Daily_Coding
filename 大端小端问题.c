#include<stdio.h>
int main()
{
	/*注意char -1 补码 1111 1111 
	%d输出是用有符号int表示的会自动提升  
	因为有符号,所以变成32位补充的是符号位就变成了 
	1111 1111 1111 .... 1111 1111(补码) 
	转化成原码就是 100 000 .... 0000 000  -1
	由于系统内部只认补码所以 1111 1111 1111 .... 1111 1111 
	在%d的时候就是-1
	在%u的时候就认为是无符号数 这时候原码就等于补码 1111 1111 1111 .... 1111 1111就是一个很大的数
	unsigned char c = -1;的时候
	 补码 1111 1111
	 但是是无符号的char变成%d 自动提升只会补0
	 0000 0000 .... 1111 1111
	 %d是有符号的 但是看到最高位是0就判断这是一个正数 255
	 无符号直接认为这是 255
	*/
	char a = -1;
	signed char b = -1;
	unsigned char c = -1;
	unsigned char d = -128;
	printf("a=%u,b=%d,c=%u,d=%d", a, b, c,d);
	system("pause");
}
//判断大小端
//int check_sys()
//{
//	int i = 1;
//	return (*(char *)&i);//取地址是首地址而且是从最低的地址开始的 所以解引用是最低的1个字节的内容
//}
//
//int main()
//{
//	int ret = check_sys();
//	if (ret == 1)
//	{
//		printf("这是小端\n");
//	}
//	else printf("这是大端\n");
//	return 0;
//	system("pause");
//}